#import "@preview/cetz:0.3.4"
#import "@preview/cetz-plot:0.1.1": plot, chart

#import "symbols.typ": *

#import "tables.typ"
#import "plots.typ"

#let doc(body, bibliography-file: "references.bib") = {
  set text(size: 12pt, lang: "ru")
  set heading(numbering: "1.1.1")
  set par(justify: true)
  show figure.where(kind: table): set figure.caption(position: top)
  set math.equation(numbering: "(1)")
  show math.equation: it => {
    if it.block and not it.has("label") [
      #counter(math.equation).update(v => v - 1)
      #math.equation(it.body, block: true, numbering: none)#label("")
    ] else {
      it
    }
  }
  show ref: it => {
    let eq = math.equation
    let el = it.element
    if el != none and el.func() == eq {
      // Override equation references.
      link(el.location(), numbering(el.numbering, ..counter(eq).at(el.location())))
    } else {
      // Other references as usual.
      it
    }
  }

  set page(
    footer: {
      align(center, "Санкт-Петербург \n 2025")
    },
  )
  align(center, text("Санкт-Петербургский государственный университет"))
  v(0.6fr)
  v(.0fr)

  let authors = ("Фаттахов Марат Русланович",)
  pad(
    top: 0.7em,
    grid(columns: (1fr,) * calc.min(3, authors.len()), gutter: 1em, ..authors.map(author => align(
        center,
        text(size: 16pt, emph(strong(author))),
      ))),
  )
  v(.1fr)
  align(center, "Выпускная квалификационная работа")
  let title = "Решение дифференциальных уравнений \n с сильным вырождением"
  align(center, text(1.75em, weight: 500, title))
  v(.1fr)
  align(center, "Уровень образования: бакалавриат")

  v(.2fr)
  align(
    center,
    [Направление _02.03.01 «Математика и компьютерные науки»_],
  )
  align(
    center,
    [Основная образовательная программа _СВ.5001.2021 «Математика и компьютерные науки»_],
  )

  v(.2fr)
  align(right, [Научный руководитель: \ профессор кафедры вычислительной математики, д.ф.-м.н. Бурова И. Г.])

  v(.1fr)
  align(
    right,
    [Рецензент: \ профессор Санкт-Петербургского Государственного \ Морского Технического Университета, д.ф.-м.н. Хазанов В. Б.],
  )
  // v(.2fr)
  // align(left, "Работа выполнена полностью, предлагаю поставить зачет")
  v(.5fr)
  pagebreak()

  set page(footer: auto, numbering: "1")

  outline(depth: 3, indent: 1em)
  pagebreak()

  body

  pagebreak()
  heading(level: 1, "Список литературы")
  bibliography(bibliography-file, full: true, title: none, style: "gost-r-705-2008-numeric")

  pagebreak()
  heading(level: 1, "Приложения")
  include "last.typ"
}

#show: doc.with(bibliography-file: "references.bib")

_Аннотация:_ Данная работа посвящена разработке и исследованию методов аппроксимации решений краевых задач для вырождающихся дифференциальных уравнений второго порядка. Основное внимание уделяется применению вариационно-сеточных методов и построению эффективных координатных систем, включая локальные сплайны нулевой и первой высоты, для аппроксимации решений в функциональных пространствах, таких как $WW_2^1(0,1)$. Теоретические результаты подкрепляются численными экспериментами на тестовых задачах с известными аналитическими решениями, что демонстрирует эффективность и практическую применимость предложенных подходов. Обсуждаются перспективы использования разработанных методов для моделирования физических процессов и решения прикладных задач.

_Ключевые слова:_ вырожденные дифференциальные уравнения, краевые задачи, вариационно-сеточный метод, аппроксимация, локальные сплайны, энергетическая норма, численные методы, сильное вырождение.

= Введение
Вырожденные дифференциальные уравнения второго порядка представляют собой важный объект исследований как в
теоретическом, так и в прикладном аспектах. Они возникают в различных областях науки и техники, таких как газовая
динамика @L2022, моделирование распространения вязких жидкостей @F1990, @P2023, квантовая космология @H2024 и теория
вероятностей @F2022. Особенность этих уравнений заключается в обращении в ноль коэффициента при старшей производной в
некоторых точках области определения, что влечёт за собой серьёзные трудности при их аналитическом и численном решении
@H2021b.

Исследования, посвящённые этим уравнениям, охватывают широкий круг вопросов, связанных с существованием, единственностью
и асимптотическим поведением решений, а также с особенностями задач Коши и краевых задач. В частности, в работе Н. Х.
Розова, В. Г. Сушко и Д. И. Чудовой @fpm рассматриваются обыкновенные дифференциальные уравнения второго порядка с
коэффициентом при старшей производной, обращающимся в нуль. В ней доказываются теоремы о существовании и единственности
решений краевых задач, уделяется внимание бисингулярным задачам, при которых коэффициенты обращаются в нуль на множестве
положительной меры. Такие задачи требуют применения специальных методов, поскольку стандартные подходы могут оказаться
неприменимыми.

Дополнительный вклад в изучение асимптотического поведения решений внесли В. П. Архипов и А. В. Глушак. В статье "Вырождающиеся
дифференциальные уравнения второго порядка. Асимптотические представления решений" @assymptotics предложены методы
нахождения собственных значений и оценки резольвенты задачи Дирихле. Эти методы позволяют исследовать решения в
комплексной плоскости и по параметру, что делает их универсальными для анализа широкого класса задач. Подход к
построению степенных асимптотик в окрестности точки вырождения разработан в работе "Первые асимптотики решений
вырождающихся дифференциальных уравнений второго порядка" @firstassymptotics, где строятся точные представления решений
с использованием специальных аппроксимаций.

Особое внимание уделено задаче Коши @cauchy, в которой начальные условия задаются в точке вырождения. В. Архипов и А.
Глушак предложили методы построения первых асимптотик решений и показали, что форма начальных условий существенно
зависит от знака коэффициента при первой производной, что оказывает влияние на вид решений и методику их построения.

Современные исследования также сосредоточены на численных методах решения вырожденных задач. Актуальными являются
подходы, основанные на вариационных принципах, разностных схемах и сплайн-аппроксимациях @H2021, @C2020, @N2021.
Локальные сплайны, в частности, обеспечивают высокую точность аппроксимации как самого решения, так и его производных,
особенно вблизи точки вырождения @S2024. Среди них выделяются полиномиальные сплайны второго порядка и сплайны Эрмита
первой высоты, позволяющие получать гладкие приближения, сохраняющие дифференциальные свойства точного решения @S2024b.

Вариационная постановка задачи в подходящем весовом пространстве Соболева @P2022 обеспечивает корректную формулировку
краевой задачи с сильным вырождением. При этом показатель степени $alpha$ в коэффициенте $k(x) = x^alpha p(x)$ лежит в
интервале $[1,2)$, что требует особого подхода к построению граничных условий и численных схем. Разработанный численный
алгоритм сочетает сплайн-аппроксимацию с проекционными методами, что обеспечивает сходимость в энергетической норме и
устойчивость решения. Эффективность предложенного метода подтверждена теоретическим анализом и численными экспериментами
@J2021.

Множество результатов в области разработано в последнее время. В @F2021, @K2021 исследуются условия существования и
единственности решений, а в @H2021 рассматривается введение весовых функций для постановки задач в пространствах
Соболева. В работе @C2020 обсуждаются собственные значения для линеаризованных задач, а в @S2023 уточняется спектральная
структура решений.

Методы, основанные на B-сплайнах и кусочно-линейных функциях, продемонстрировали свою эффективность @M2023, @N2021.
Эрмитовы сплайны @L2023 обеспечивают высокий порядок аппроксимации и позволяют приближать как само решение, так и его
производные @K2022. В @D2022 изучается нестационарное интегро-дифференциальное уравнение с вырожденным оператором, а в
@P2024 предлагается метод локального улучшения аппроксимаций, полученных методом конечных элементов.

Особый интерес представляют случаи с периодическими коэффициентами или решениями, для которых применяются
тригонометрические сплайны @V2022. Вариационные методы оказываются особенно полезны в задачах с неоднородной структурой
или переменными коэффициентами. В @N2021 описан алгоритм адаптивной сетки, позволяющий улучшить точность на участках с
резкими изменениями решений @L2021.

Заключительно, предложенный в настоящей работе подход объединяет достоинства вариационного формулирования и
сплайн-аппроксимации, обеспечивает высокую точность и устойчивость при решении краевых задач с сильным вырождением, а
также демонстрирует широкую применимость в прикладных задачах, связанных с моделированием сложных физических процессов
@R2023b.

= Цель работы
Разработать численные методы приближенного решения краевых задач для вырождающихся дифференциальных уравнений
второго порядка. В частности, основное внимание уделяется:

1. Формализации аппроксимации в функциональных пространствах, таких как $WW_2^1(0,1)$, с использованием
  вариационно-сеточных методов.
2. Разработке и анализу координатных систем для одномерных задач, обеспечивающих сходимость аппроксимации в энергетической
  норме.
3. Оценке порядка аппроксимации, полученной с использованием линейной интерполяции, а также практическому применению
  методов к конкретным задачам.
4. Построению численных методов и их верификации на тестовых примерах с известными аналитическими решениями.

Целью является не только теоретический анализ разработанных методов, но и их практическое применение, что позволит
подтвердить эффективность предложенных подходов.

= Аппроксимация решения первой краевой задачи для вырождающихся одномерных дифференциальных уравнений второго порядка

== Вид уравнения
В данной главе работы будет рассмотрено уравнение следующего вида:
$
  -d / dx [x^alpha p(x) du / dx] + q(x) u = f(x), quad 0 < x < 1, quad f in L2(0, 1),\
  q "измерима, ограничена, неотрицательна на" [0,1]\
  alpha = const > 0, space p in C^1 [0,1], space p(x) >= p_0 = const > 0\
  u in WW_2^1(0,1)
$
== Аппроксимация в пространстве $WW_2^1$ <2.2>
=== Основа вариацонно-сеточного метода
Пусть в гильбертовом пространстве $H$ действует линейный положительно-определенный оператор $A$ и требуется найти
решение уравнения
$
  A u = f, quad f in H
$
Принято вводить функционал энергии и энергетическую норму с энергетическим произведением:
$
  [u,v]_A := (A u,v),\
  norm(u)_A^2 := [u,u]_A = (A u,u),\
  cal(F)(u) := 1 / 2[u,u]_A - (f,u)
$
При положительной определенности оператора $A$ функционал энергии является выпуклым, из чего следует, что ноль его
производной является точкой минимума.
$
  cal(F)'(u)h = [u,h]_A - (f,h)\
  cal(F)'(u_0) = 0 <=> forall h in H quad [u_0,h]_A = (f,h) <=> A u_0 = f\
$
Если решение $u_0$ аппроксимируется в конечномерном пространстве $H_n$ с энергетическим произведением $[dot,dot]_A$, то
критерием минимальности функционала энергии в точке $u_n in H_n$ будет следующая система линейных уравнений:
$
  u_n = sum_(k=1)^n a_k phi_k, " где Lin" {phi_1,dots,phi_n} = H_n,\
  (cal(F) bar_H_n) '(u_n) = 0 <=> partial / (partial a_k) cal(F)(u_n) = 0, space k = 1,...,n\
  partial / (partial a_k) cal(F)(u_n) = partial / (partial a_k) [1 / 2 sum_(i=1)^n sum_(k=1)^n a_i a_k [phi_i, phi_k]_A - sum_(i=1)^n a_i (f, phi_i)] =\
  = sum_(i=1)^n a_i [phi_i, phi_k]_A - (f, phi_k) =0, space k = 1,...,n\
$<system>
Приведенная схема называется методом Ритца.

Основой сеточного метода аппроксимации является выбор функций $phi_i$, которые связаны с координатной сеткой в области
аппроксимации и задаются простыми формулами. Эти базисные функции $phi_i$ мы будем называть координатными функциями.
Выбор функций ограничен лишь условием полноты системы ${{phi_(n, i)}_(i=1)^k_n}_n$, где для каждого $n$ задается
подпространство $H_n$ размерности $k_n$ и функции $phi_(n, i)$ образуют базис в этом подпространстве, а полнота системы
-- это условие
$
  forall u in H space lim_(n -> oo) inf_(v_n in H_n) norm(u - v_n)_A = 0,
$
то есть любая функция $u$ может быть аппроксимирована с любой точностью в энергетической норме.

В книге @michbook показано, что если координатная система ${phi_(n, i)}$ полна в смысле описанном выше, то построенная
при помощи системы @system аппроксимация сходится в энергетической норме к решению исходного уравнения.

Р. Курантом в @kurant было показано, что необязательно выбирать последовательность подпространств $H_n$, которые строго
вложены друг в друга, как изначально предполагалось в методе Ритца, главное, чтобы система базисов этих пространств была
полна.

== Одномерный случай
Вернемся к поставленной задаче, в @methods описаны необходимые и достаточные условия для минимальной координатной
системы в $WW_p^s (Omega subset RR^m)$ вида
$
  {phi_(q, j, h) (x) = omega_q (x / h - j)}_(j in J_h, abs(q) = 0, ..., s-1),
$
которая при помощи функции $u_h$ аппроксимирует любую функцию $u in C_0^s (overline(Omega))$ в метрике $circle(WW)_p^s (Omega)$,
а также эту же функцию $u$ в метрике $C^(s-1) (K)$ для любого компакта $K subset Omega$ при $h -> 0$. Здесь $h$ -- шаг
сетки, $J_h$ -- конечный набор целых мультииндексов размера $m$, такой что $union.big_(j in J_h) "supp" phi_(q, j, h) supset Omega space forall q$,
а аппроксимирующая функция $u_h$ определяется как
$
  sum_(abs(q) = 0)^(s-1) sum_(j in J_h) h^q u^((q))((j+bb(1))h) omega_q (x / h-j)
$

Рассмотрим одномерный случай, то есть $m = 1$ и частный пример $Omega = (0,1)$. Для данного случая в @methods подробно
описаны рекурсивные формулы для построения функций $omega_q$. Но эти же функции можно получить рассмотрев более простую
задачу -- построение полиномиальной координатной системы.

// == Полиномиальные координатные системы
// Будем использовать общепринятый сеточный метод аппроксимации. Начнем с отрезка $[0,2]$ и кусочных функций на нем. Пусть
// $
//   omega_q = cases(phi_q (x) &", " x in [0,1], psi_q (x-1) &", " x in [1,2], 0 &", " x in.not [0,2]), quad psi_q, phi_q : [0,1] -> RR "полиномы", space q = 0,...,s-1 \
//   phi_q (0) = 0, space psi_q (1) = 0, space phi_q (1) = psi_q (0), quad q = 0,...,s-1
// $

// Теперь рассмотрим сдвиги функций $omega_q$:
// $
//   {omega_(j, q) := omega_q (x-j)}_(j in ZZ, q = 0,...,s-1)
// $
// Носители этих функций -- отрезки $[j, j+2]$. Теперь построим приближение функции $u in C^(s-1) ([0,2])$ в виде
// $
//   tilde(u) (x) = sum_(j in ZZ inter [0,2]) sum_(q=0)^(s-1) u^((q)) (j) omega_(j, q) (x), quad x in [0,2]
// $
// Рассмотрим отрезок $[0,1]$, тогда в формуле выше записан некий полином степени $s-1$ с коэффициентами $u^((q)) (j)$.
// Чтобы найти функции $phi_q, psi_q$ необходимо предположить, что для $u = 1,x,...,x^r$ выполняется равенство $tilde(u) = u$.
// Это условие дает систему линейных уравнений для коэффициентов $phi_q, psi_q$. Понятно, что стоит рассматривать $r >= s-1$,
// так как иначе последние производные будут равны нулю и функцию $omega_(s-1)$ мы не найдем. Начиная с некоторого $r$ эта
// система будет иметь единственное решение, которое и будет определять функции $omega_q$.

// Приведу решения для $s = 1,2,3$:

// 1. $s = 1$
// $
//   omega_0 (x) = cases(x &", " x in [0,1], 2-x &", " x in [1,2], 0 &", " x in.not [0,2])
// $
// 2. $s = 2$
// $
//   &omega_0 (x) = cases(-2x^3 + 3x^2 &", " x in [0,1], 2x^3 - 9x^2 + 12x - 4 &", " x in [1,2], 0 &", " x in.not [0,2]) \
//   &omega_1 (x) = cases(x^3 - x^2 &", " x in [0,1], x^3 - 5x^2 + 8x - 4 &", " x in [1,2], 0 &", " x in.not [0,2])
// $

// 3. $s = 3$
// $
//   &omega_0 (x) = cases(
//     6x^5 - 15x^4 + 10x^3 &", " x in [0,1],
//     -6x^5 + 45x^4 - 130x^3 + 180^2 - 120x + 32 &", " x in [1,2],
//     0 &", " x in.not [0,2],
//   ) \
//   &omega_1 (x) = cases(
//     -3x^5 + 7x^4 - 4x^3 &", " x in [0,1],
//     -3x^5 + 23x^4 - 68x^3 + 96x^2 -64x + 16 &", " x in [1,2],
//     0 &", " x in.not [0,2],
//   ) \
//   &omega_2 (x) = cases(
//     1 / 2x^5 - x^4 + 1 / 2x^3 &", " x in [0,1],
//     -1 / 2x^5 + 4x^4 - 25 / 2x^3 + 19x^2 - 14x + 4 &", " x in [1,2],
//     0 &", " x in.not [0,2],
//   )
// $

// Далее, следуя теории из @methods, добавляем шаг сетки, строим систему ${phi_(q, j, h)}_(j in ZZ, q = 0,...,s-1)$ и
// аппроксимируем функцию $u in C^(s-1) (0,1)$.

== Вид системы при различных высотах $s$
В @system для нахождения коэффициентов $a_i$ приводится явный вид системы линейных уравнений. В случае $s > 0$ систему
можно привести к простому виду матричного уравнения. Рассмотрим например $s = 1$.

$
  u_n = sum_(j = 1)^n (a_(j, 0) omega_(j, 0) + a_(j, 1) omega_(j, 1)) \
  partial / (partial a_(j, 0)) cal(F)(u_n) = partial / (partial a_(j, 1)) cal(F)(u_n) = 0, space j = 1,...,n
$

Можно выделить 4 вида взаимодействия между базисными функциями $omega_(j, q)$:
$
  &M_(0, 0) = ([omega_(j, 0), omega_(i, 0)]_A)_(i, j) quad quad quad
  &&M_(0, 1) = ([omega_(j, 0), omega_(i, 1)]_A)_(i, j) \
  &M_(1, 0) = ([omega_(j, 1), omega_(i, 0)]_A)_(i, j) quad quad quad
  &&M_(1, 1) = ([omega_(j, 1), omega_(i, 1)]_A)_(i, j) \
$

А значит представить всю систему в виде матричного уравнения
$
  mat(M_(0, 0), M_(0, 1); M_(1, 0), M_(1, 1)) vec(a_0, a_1) = vec((f, omega_0), (f, omega_1))
$

Так как носители функций $omega_(j, q)$ -- отрезки $[j, j+2]$, то матрицы $M_(0 0), M_(0 1), M_(1 0), M_(1 1)$ будут
иметь трехдиагональный вид, что упрощает решение.

Аналогично для остальных случаев $s > 1$ систему можно свести к матричному уравнению
$
  mat(
    M_(0, 0), M_(0, 1), ..., M_(0, s-1); M_(1, 0), M_(1, 1), ..., M_(1, s-1); dots.v, dots.v, dots.down, dots.v; M_(s-1, 0), M_(s-1, 1), ..., M_(s-1, s-1)
  ) vec(a_0, a_1, ..., a_(s-1)) = vec((f, omega_0), (f, omega_1), ..., (f, omega_(s-1)))
$

== Порядок аппроксимации
Вернемся к нашей задаче, одномерный случай, $s = 0$, $Omega = (0,1)$. Координатная система в этом случае имеет вид
$
  {phi_(j, h) (x) = omega (x / h - j)}_(j in J_h)
$
А аппроксимирующая функция имеет вид
$
  u_h (x) = sum_(j in J_h) u((j+1)h) omega (x / h - j)
$
Для удобства введем обозначение $x_j := j h$. Тогда на промежутке $[x_(j), x_(j+1)]$ ненулевыми $phi_(dot, h)$ будут
только $phi_(j, h)$ и $phi_(j-1, h)$.

Тогда на этом промежутке
$
  u_h (x) = u(x_(j+1)) phi_(j, h) (x) + u(x_j) phi_(j-1, h) (x),
$
но на каждом промежутке $[x_j, x_(j+1)]$ $phi_(dot, h)$ являются полиномами степени не выше 1, и верно $phi_(i-1,h) (x_i) = 1$,
то есть на самом деле мы имеем дело с линейной интерполяцией: вписываем ломаную в график функции $u$ в точках $x_j$.

Для интерполяционного многочлена есть оценка оценка остатка:
$
  x in [x_j, x_(j+1)] =>\
  abs(u(x) - u_h (x)) <= sup_(x in (x_j, x_(j+1))) abs(u''(x)) dot 1 / 2! abs((x-x_j)(x-x_(j+1)))
$
Несложно проверить, что $abs((x-x_j)(x-x_(j+1))) <= 1 / 4 h^2$, тогда
$
  norm(u-u_h)_C[x_j, x_(j+1)] <= 1 / 8 h^2 sup_(x in [x_j, x_(j+1)]) abs(u''(x))
$
То есть мы ожидаем не лучше, чем квадратичную сходимость.

== Погрешность приближения
В предыдущем пункте была получена оценка погрешности приближения $u$ линейной интерполяцией. В @gusman получена важная
для нас оценка:
$
  norm(u - u^h)_A <= norm(u - u_h)_A,
$
где $u^h$ -- приближенное решение, получаемое при помощи метода Ритца, а $u_h$ -- вписанная в график $u$ ломаная, с
узлами в точках $x_j$. Таким образом, при наличии оценки на $norm(u - u_h)_A$, можно оценить погрешность приближения $u^h$ к $u$.

=== Случай слабого вырождения
Случай $0 < alpha < 1$ называется случаем слабого вырождения. В данном случае в @methods было показано, что
$
  norm(u - u_h)_A <= C norm(f)_L_2 h^((1-alpha) slash 2).
$
И данная оценка точна в том смысле, что существует функция $u$, для которой $norm(u - u_h)_A = C norm(f)_L_2 h^((1-alpha) slash 2)$.

=== Случай сильного вырождения
Случай $1 <= alpha < 2$ называется случаем сильного вырождения. В данном случае в @methods было показано, что
$
  norm(u - u_h)_A <= C norm(f)_L_2 h^(1 - alpha / 2).
$
И данная оценка почти точна в том смысле, что для любого $epsilon > 0$ существует функция $u$, для которой $norm(u - u_h)_A >= C h^(1 - alpha / 2 - epsilon)$.

==== Улучшение оценки
На самом деле (см. @methods), при $f in L_r (0,1), space 2 < r <= oo$, можно получить лучшую оценку в случае $1 <= alpha < 2$:
$
  norm(u - u_h)_A <= C norm(f)_L_r h^((3 - alpha) / 2 - 1 / r),
$
где при $r = oo$ следует считать $1 / r = 0$.

== Применение к конкретным задачам

=== Аппроксимация сплайнами нулевой высоты
В качестве первого примера рассмотрим задачу
$
  -d / (dx) (x^alpha du / dx) + u = (x^(3-alpha)-2(3-alpha)x-1) / (3-alpha),\
  0 < x < 1 quad 1 <= alpha <= 2
$
Известно, что в данном случае нужно ставить условие только на конце $u(1)$. Пусть $u(1) = 0$. Правая часть уравнения
получалась подстановкой
$
  u(x) = (x^(3-alpha)-1) / (3-alpha),
$
то есть это точное решение задачи.

Возьмем натуральное $n$ и по нему построим $h = 1 slash (n+1)$, тогда в координатной системе ${phi_(i,h)}$ первая и
последняя функции выглядят как на @r0.

#align(
  center,
  [#figure(
      cetz.canvas({
        import cetz.draw: *

        set-style(
          axes: (stroke: .5pt, tick: (stroke: .5pt)),
          legend: (stroke: 0.25pt, orientation: ttb, item: (spacing: .3), scale: 50%),
        )

        let wf = x => calc.max(1 - calc.abs(x - 1), 0)
        let n = 10
        let h = 1 / (n + 1)

        let phi_first = x => wf(x / h + 1)
        let phi_last = x => wf(x / h - n)

        plot.plot(
          size: (12, 5),
          x-tick-step: 0.25,
          y-tick-step: 0.5,
          y-min: -0.25,
          y-max: 1.45,
          legend: "inner-north",
          {
            let domain = (-0.25, 1.25)
            plot.add(phi_first, domain: domain, samples: 1000, label: [$phi_(-1,h)$])
            plot.add(phi_last, domain: domain, samples: 1000, label: [$phi_(n,h)$])
          },
        )
      }),
      caption: [Первая и последняя функции в координатной системе ${phi_(i,h)}$],
    )<r0>],
)
Будем строить аппроксимирующую функцию вида $u_h = sum_(k=-1)^n a_k phi_(k,h)$, заметим, что так как $u(1) = 0$, то
коэффициент при последнем члене $a_n = 0$.

По предложенному в @2.2[пункте] методу строим аппроксимирующую путем решения системы
$
  sum_(k=-1)^(n-1) a_k [phi_(k,h), phi_(j,h)]_A = (f, phi_(j,h)), quad j = -1,...,n
$
Тут
$
  A u = -d / (dx) (x^alpha du / dx) + u,\
  [phi_(k,h), phi_(j,h)]_A = (A phi_(k,h), phi_(j,h)) =\ = integral_0^1 {(-d / (dx) (x^alpha d / dx phi_(k,h)) + phi_(k,h)) dot phi_(j,h)} dx =\
  = integral_0^1 {x^alpha (d / dx phi_(k,h)) (d / dx phi_(j,h)) + phi_(k,h) phi_(j,h)} dx - lr(x^alpha (d / dx phi_(k,h)) phi_(j,h) |)_0^1
$
Видно, что подстановка $lr(x^alpha (d / dx phi_(k,h)) phi_(j,h) |)_0^1$ равна нулю в случае, если хотя бы один из $k$ или $j$ не
равен $n$. Так как $k = -1,...,n-1$, то подстановка всегда равна $0$. Произведение в правой части -- классическое
скалярное произведение функций
$
  (f, phi_(j,h)) = integral_0^1 f(x) phi_(j,h) (x) d x
$

Расчеты производились в системе математических вычислений с точностью 8 знаков после запятой.

Результаты вычислений приведены в виде таблиц абсолютных погрешностей, на @t1[Таблице] приведены подробные результаты вычислений для $alpha = 1$. На @t2[Таблице] и @t3[Таблице] приведены результаты вычислений для $alpha = 1.5$ и $alpha = 1.8$ соответственно.

#show table.cell.where(y: 0): strong
#set table(
  stroke: (x, y) => if y == 0 {
    (bottom: 0.7pt + black)
  },
  align: (x, y) => (if x > 0 { center } else { left }),
)

#tables.t1<t1>
#tables.t2

Также приведены графики приближенного решения и абсолютных погрешностей для $alpha = 1$. На @r1 приведены графики приближенного решения и самого решения, а на @r2 -- график абсолютной погрешности.

#grid(
  columns: (1fr, 1fr),
  column-gutter: 3em,
  row-gutter: 2em,
  align(right, [#figure(plots.p1, caption: [Приближенное решение], supplement: [Рис.])<r1>]),
  [#figure(plots.p2, caption: [Абсолютная погрешность], supplement: [Рис.])<r2>],
)

Также приведены графики абсолютных погрешности при разных $h$. На @r3 приведены графики абсолютной погрешности при $h = 0.01$, а на @r4 -- при $h = 0.001$.
#grid(
  columns: (1fr, 1fr),
  column-gutter: 3em,
  row-gutter: 2em,
  align(right, [#figure(plots.p3, caption: [Абсолютная погрешность], supplement: [Рис.])<r3>]),
  [#figure(plots.p4, caption: [Абсолютная погрешность], supplement: [Рис.])<r4>],
)

=== Аппроксимация сплайнами первой высоты
В качестве второго примера рассмотрим задачу с более сложным для аппроксимации решением:
$
  f(x) = 1 / x (1 + x)^(1 - alpha) (x (-1 + x^2)^2 + x^alpha (4 x (1 + (2 - 5 x) x) + (-1 + x)^2 (-1 + 4 x) alpha + (-1 + x)^2 alpha^2)),\
  -d / (d x) (x^alpha du / dx) + u = f(x), quad 0 < x < 1, quad 1 <= alpha < 2, quad u(1) = u'(1) = 0
$
// u = (x + 1) ** (3 - alpha) * (1 - x) ** 2
// f = ((1 + x)^(1 - α) (x (-1 + x^2)^2 + x^α (4 x (1 + (2 - 5 x) x) + (-1 + x)^2 (-1 + 4 x) α + (-1 + x)^2 α^2)))/x
с аналитическим решением $u(x) = (x+1)^(3-alpha) (1-x)^2$.

Построим базисные функции $omega_0, omega_1$, их вид приведен на @w0 и @w1.
#grid(
  columns: (1fr, 1fr),
  [
    #figure(
      plots.p5,
      caption: [Базисная функция $omega_0$],
    )<w0>],
  [
    #figure(
      plots.p6,
      caption: [Базисная функция $omega_1$],
    )<w1>],
)

В данном случае построение аппроксимирующего решения является совмещением двух этапов:
+ аппроксимируем значения функции-решения и значения ее производной в точках сетки ${x_j}_(j=0)^(n-1)$
+ вписываем базисные функции в полученый каркас приближенного решения
$
  u_h = sum_(j=0)^(n-1) tilde(u)(x_j) omega_(j,0) + h dot tilde(u)'(x_j) omega_(j,1)
$

Формулы подсчета энергетического произведения остаются теми же, что и в случае нулевой высоты.

Результаты вычислений приведены в виде таблиц абсолютных погрешностей. На @t4[Таблице] приведены результаты вычислений для $alpha = 1$. На @t5[Таблице] приведены результаты вычислений для $alpha = 1.5$.

#grid(
  columns: (1fr, 1fr),
  [#tables.t3<t4>], [#tables.t4<t5>],
)

Также приведены графики приближенного решения и абсолютных погрешностей. На левом графике @r5 приведены графики приближенного решения и самого решения, на правом графике @r5 -- график абсолютной погрешности относительно решения.
#figure(
  grid(
    columns: (1fr, 1fr),
    column-gutter: 3em,
    row-gutter: 2em,
    align(right, plots.p7), plots.p8,
  ),
  caption: [Приближенное решение и абсолютная погрешность, $alpha = 1.5$],
  supplement: [Рис.],
)<r5>

На @r6 приведены графики приближенной производной решения и абсолютной погрешности. На левом графике @r6 приведены графики производной приближенного решения и самой производной решения, на правом графике @r6 -- график абсолютной погрешности относительно производной решения.
#figure(
  grid(
    columns: (1fr, 1fr),
    column-gutter: 3em,
    row-gutter: 2em,
    align(right, plots.p9), plots.p10,
  ),
  caption: [Приближенная производная решения и абсолютная погрешность, $alpha = 1.5$],
  supplement: [Рис.],
)<r6>

Пример специально подобран так, чтобы наглядно показать ограничения метода. В данном случае производная плохо аппроксимируется многочленами низких степеней.

== Сравнение с другимим методами

В этой главе ответим на вопрос, как преймущество метода в виде использования нескольких высот сплайнов сравнивается с другими методами.

Для этого будем считать, что мы имеем каркас приближенного решения в узлах сетки. По этому каркасу проведем интерполяцию самыми используемыми методами:
+ Линейная интерполяция
+ Эрмитовы $C^1$ сплайны
+ Кубические $C^2$ сплайны
Далее сравним графики полученных приближений, а также различные метрики для оценки качества приближения.

=== Линейная интерполяция
Наиболее простой метод аппроксимации, где функция приближается кусочно-линейной функцией, соединяющей соседние узловые точки. Имея значения функции в узлах сетки $(x_j, u(x_j))$, на каждом интервале $[x_j, x_(j+1)]$ строится линейная функция:
$
  L(x) = u(x_j) + (u(x_(j+1)) - u(x_j)) / (x_(j+1) - x_j) dot (x - x_j)
$

Линейная интерполяция обеспечивает непрерывность аппроксимации, но не гарантирует непрерывности производных. Предлагаемый метод строит линейную интерполяцию в случае нулевой высоты сплайнов.

=== Эрмитовы $C^1$ сплайны
При наличии только значений функции (без производных), для построения эрмитовых сплайнов необходимо сначала аппроксимировать производные в узлах. Обычно это делается с помощью разделенных разностей:
$
  u'(x_j) approx (u(x_(j+1)) - u(x_(j-1))) / (2h), quad u'(x_0) approx (u(x_1) - u(x_0)) / h, quad u'(x_n) approx (u(x_n) - u(x_(n-1))) / h
$
После определения приближенных значений производных в узлах, эрмитов сплайн строится аналогично случаю с известными производными:
$
  H(x) = u(x_j)H_(j,0)(t) + u(x_(j+1))H_(j,1)(t) + h dot u'(x_j)H_(j,2)(t) + h dot u'(x_(j+1))H_(j,3)(t),
$
где $t = (x - x_j) / h$ и $H_(j,i)(t)$ - базисные кубические многочлены:
$
  &H_(j,0)(t) = 2t³ - 3t² + 1\
  &H_(j,1)(t) = -2t³ + 3t²\
  &H_(j,2)(t) = t³ - 2t² + t\
  &H_(j,3)(t) = t³ - t²\
$

Интерполяция с помощью эрмитовых сплайнов обеспечивает непрерывность аппроксимации и ее первой производной. Предлагаемый метод интерполяцию строит с помощью эрмитовых сплайнов в случае первой высоты сплайнов.

=== Кубические $C^2$ сплайны
С повышением степени многочленов, естественным становится условие нуля вторых производных в узлах сетки. Построение кубического сплайна сводится к решению системы линейных уравнений с трехдиагональной матрицей.

=== Сравнение результатов

Для исследования возьмем задачу из второго примера с $alpha = 1.5$. Каркас приближенного решения построим с помощью предложенного метода и нулевой высоты сплайнов на сетке с пятью узлами. Проведем интерполяцию при помощи всех методов и отобразим на графиках абсолютные значения ошибок относительно решения и производной решения.

Абсолютные ошибки относительно решения изображены на @r10.
#align(center)[
  #figure(
    plots.p_comparison_errs,
    caption: [График абсолютных ошибок относительно решения при разных методах],
  )<r10>
]

// Для оценивания результатов посчитаем несколько метрик:
// $
//   E_oo = max_(j) |u(x_j) - L(x_j)|, quad E_1 = sum_(j) |u(x_j) - L(x_j)|, quad E_2 = sqrt(sum_(j) (u(x_j) - L(x_j))²)
// $

// Данные по ошибкам приведены в @t6[Таблице]:
// #align(center)[
//   #figure(
//     {
//       set table(align: (x, _) => if x == 0 { left } else { right })
//       table(
//         columns: (auto, 1fr, 1fr, 1fr),
//         stroke: none,
//         row-gutter: (2.2pt, auto),

//         table.hline(y: 1),

//         table.header([Метод], [$E_oo$], [$E_1$], [$E_2$]),

//         [Линейная интерполяция], [0.0310], [2.2580], [0.1957],
//         [Эрмитовы $C^1$ сплайны], [0.0225], [1.4333], [0.1338],
//         [Кубические $C^2$ сплайны], [0.0199], [1.4153], [0.1156],
//         [Предлагаемый метод], [#text(weight: "semibold")[0.0199]], [#text(weight: "semibold")[0.7862]], [#text(
//             weight: "semibold",
//           )[0.0661]],
//       )
//     },
//     caption: [Показатели $E_oo, E_1, E_2$ для разных методов при приближении решения дифференциального уравнения],
//   )<t6>
// ]

Основным преймуществом предлагаемого метода является легкое построение приближения производной решения, сравним с другими методами. На @r8 приведен график абсолютных ошибок относительно производной решения.

#align(center)[
  #figure(
    plots.p_prime_comparison_errs,
    caption: [График абсолютных ошибок относительно производной решения при разных методах],
  )<r8>
]

// Метрики ошибок относительно производной решения приведены в @t7[Таблице].
// #align(center)[
//   #figure(
//     {
//       set table(align: (x, _) => if x == 0 { left } else { right })
//       table(
//         columns: (auto, 1fr, 1fr, 1fr),
//         stroke: none,
//         row-gutter: (2.2pt, auto),

//         table.hline(y: 1),

//         table.header([Метод], [$E_oo$], [$E_1$], [$E_2$]),

//         [Линейная интерполяция], [0.5669], [36.1705], [3.0591],
//         [Эрмитовы $C^1$ сплайны], [0.5669], [24.4593], [2.2798],
//         [Кубические $C^2$ сплайны], [0.3932], [19.3063], [1.7325],
//         [Предлагаемый метод], [#text(weight: "semibold")[0.3907]], [#text(weight: "semibold")[9.4893]], [#text(
//             weight: "semibold",
//           )[1.1537]],
//       )
//     },
//     caption: [Показатели $E_oo, E_1, E_2$ для разных методов при приближении производной решения дифференциального уравнения],
//   )<t7>
// ]

=== Выводы из сравнения

На основе проведенного сравнения различных методов интерполяции для решения вырождающихся дифференциальных уравнений второго порядка можно сделать следующие выводы:

// + *Точность аппроксимации функции*: Результаты показывают, что предлагаемый метод демонстрирует наилучшие показатели по всем трем метрикам ($E_oo$, $E_1$, $E_2$) при аппроксимации самой функции. По максимальной ошибке ($E_oo$) он сравним с кубическими сплайнами (0.0199), но значительно превосходит все методы по интегральным метрикам. Особенно заметно преимущество в $E_1$ (0.7862 против 1.4153 у ближайшего конкурента) и $E_2$ (0.0661 против 0.1156), что указывает на более равномерное и точное приближение по всей области определения.

// + *Точность аппроксимации производной*: Особенно важным является преимущество предлагаемого метода при аппроксимации производной решения. По всем метрикам он демонстрирует существенно лучшие результаты, причем по метрике $E_1$ разница более чем в два раза (9.4893 против 19.3063 у кубических сплайнов), а по $E_2$ - в полтора раза (1.1537 против 1.7325). Это критически важно при решении вырождающихся уравнений, где точность приближения производных имеет ключевое значение для корректного моделирования поведения решения вблизи точки вырождения.

+ *Графический анализ*: Графики абсолютных ошибок на @r8 и @r10 наглядно демонстрируют, что предлагаемый метод обеспечивает более равномерное распределение погрешности по всей области, в то время как другие методы дают значительные локальные всплески ошибок, особенно при приближении производной решения.

+ *Практическая значимость*: Существенное улучшение в аппроксимации производной решения делает предлагаемый метод особенно ценным для практических задач, где требуется не только знание самой функции, но и ее производных, например, в задачах моделирования физических процессов, где производная часто имеет ясный физический смысл (скорость, поток и т.д.).

// === Применение метода к задаче о поиске стационарного распределения волатильности
// Модели волатильности в математике финансов часто приводят к дифференциальным уравнениям с вырожденными коэффициентами, особенно около нуля. Один из классических примеров — модель Кокса–Ингерсола–Росса (CIR) @Cox1985, используемая для моделирования процентных ставок и волатильности:
// $
// d v_t = kappa (theta - v_t) d t + sigma sqrt(v_t) d W_t
// $

// Эта стохастическая модель порождает уравнение Фоккера–Планка @jordan1998variational для плотности распределения $p(v,t)$, которое имеет сильное вырождение при $v=0$:
// $
//   (diff p) / (diff t) = - diff/(diff v) [(kappa (theta - v))p]+1/2 diff^2/(diff v^2) [sigma^2 v p]
// $
// Для стационарного распределения имеем $diff p slash diff t = 0$, и мы получаем уравнение
// $
//   0 = - diff/(diff v) [(kappa (theta - v))p]+1/2 diff^2/(diff v^2) [sigma^2 v p]
// $
// Перейдем к принятым обозначениям: $x = v, u(x) = p_0(x)$, где $p_0(x)$ — искомое стационарное распределение. Если использовать метод интегрирующего множителя и в качестве него взять $mu(x) = -x^((2 kappa theta)/(sigma^2)+1)e^((2 kappa x)/sigma^2)$, то легко проверяется, что уравнение эквивалентно
// $
//   -(x^(2- (2 kappa theta)/sigma^2) sigma^2/2 e^((2 kappa x)/sigma^2) u')' - kappa x^(1-(2 kappa theta)/sigma^2) e^((2 kappa x) / sigma^2) u(x) = 0
// $
// То есть
// $
// alpha = 2- (2 kappa theta)/sigma^2, quad
// p(x) = sigma^2/2 e^((2 kappa x)/sigma^2), quad
// q(x) = -kappa x^(1-(2 kappa theta)/sigma^2) e^((2 kappa x) / sigma^2), quad
// f(x) = 0
// $
// В терминах исследуемой нами структуры.

// Таким образом данная структура аналогична рассматриваемой в текущей работе, и мы можем применить метод, описанный выше.



// В качестве минуса такого подхода можно отметить большую погрешность в начале отрезка, где решение не закреплено. Так как
// у нас нет информации о поведении слева от точки 0, то мы не можем также точно построить каркас, как в середине отрезка.

// === Задача о двух закрепленных концах
// Рассмотрим более подходящий вариант задачи для аппроксимации сплайнами первого уровня.
// $
//   -d / (d x) (x^alpha du/dx) + u = (x-1)^2 x^(3-alpha) + 2x (2 x^2 (alpha-5) - 3 x (alpha-4) + alpha - 3), \
//   0 < x < 1, quad 1 <= alpha < 2, quad u(0) = u(1) = u'(0) = u'(1) = 0
// $
// с аналитическим решением $u(x) = x ^ (3 - alpha) (1 - x) ^ 2$.

// Графики приближенного решения и абсолютных погрешностей для $alpha = 1.5$:
// #figure(
//   grid(columns: (1fr, 1fr), column-gutter: 3em, row-gutter: 2em, align(right, plots.p11), plots.p12),
//   caption: [Приближенное решение и абсолютная погрешность],
//   supplement: [Рис.],
// )
// #figure(
//   grid(columns: (1fr, 1fr), column-gutter: 3em, row-gutter: 2em, align(right, plots.p13), plots.p14),
//   caption: [Приближенная производная решения и абсолютная погрешность],
//   supplement: [Рис.],
// )

// #pagebreak()
// Таблица абсолютных погрешностей
// #tables.t5

= Заключение
+ В ходе работы был исследован метод аппроксимации решений краевых задач для вырождающихся дифференциальных уравнений второго порядка, основанный на вариационно-сеточных методах. В процессе реализации выделены основные этапы аппроксимации в функциональных пространствах, таких как $WW_2^1(0,1)$, с использованием линейных базисных функций, что позволило обеспечить сходимость решений в энергетической норме.

+ Показано, что использование предложенной координатной системы позволяет с высокой точностью аппроксимировать решения в рамках заданной задачи. Анализ порядка аппроксимации показал, что для линейной интерполяции ошибки аппроксимации оцениваются квадратично. Верификация полученных численных решений на тестовых примерах с известными аналитическими решениями подтвердила корректность методов и их применимость к реальным задачам.

+ Сравнительный анализ с другими методами интерполяции (линейная интерполяция, эрмитовы $C^1$ сплайны, кубические $C^2$ сплайны) продемонстрировал существенное преимущество предлагаемого подхода как по точности аппроксимации самого решения, так и особенно его производной. 

+ Важной новацией является разработка программного пакета на языке Python, интегрированного с популярными научными библиотеками NumPy, SciPy и SymPy. Это обеспечивает простоту практического применения метода к широкому кругу задач исследуемой формы, а также возможность его использования в образовательных и исследовательских целях. Совместимость с экосистемой научных вычислений Python существенно расширяет аудиторию потенциальных пользователей метода.
