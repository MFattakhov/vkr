#import "symbols.typ": *

#let doc(body, bibliography-file: "references.bib") = {
  set text(size: 14pt, lang: "ru")
  set heading(numbering: "1.1.1")
  set math.equation(numbering: "(1)")
  show ref: it => {
    let eq = math.equation
    let el = it.element
    if el != none and el.func() == eq {
      // Override equation references.
      link(el.location(), numbering(el.numbering, ..counter(eq).at(el.location())))
    } else {
      // Other references as usual.
      it
    }
  }

  body

  pagebreak()

  heading(level: 1, "Список литературы")
  bibliography(bibliography-file, full: true, title: none)
}

#show: doc.with(bibliography-file: "references.bib")

= Дифференциальные уравнения с сильным вырождением
ДУ с сильным вырождением называют уравнения, в которых старшая производная умножается на функцию, которая может
обращаться в ноль в области определения. Например, для второго порядка общий вид будет:
$
  a(x,t)u_t = b(x,t)u_(x x) + c(x,t)u_x + d(x)u + f(x,t), quad x,t in Omega times T,\
  exists x_0,t_0 in Omega times T: a(x_0,t_0) = 0
$
Или в стационарном случае
$
  a(x)u_(x x) + b(x)u_x + c(x) u = f(x), quad x in Omega,\
  exists x_0 in Omega: a(x_0) = 0
$
Такие уравнения требуют особых численных методов решения, также возникают естественные граничные условия.

Они могут возникать в задачах теплопроводности, гидродинамики.

Для приложений требуется задавать некоторые граничные условия, которые задают начальные параметры системы. Случай, когда
условие состоит в задании начальных значений искомой функции на границе, называется *первой краевой задачей*, или
*задачей Дирихле*.

= Аппроксимация решения первой краевой задачи для вырождающихся одномерных дифференциальных уравнений второго порядка

== Вид уравнения
В данной главе работы будет рассмотрено уравнение следующего вида:
$
  -d/dx [x^alpha p(x) du/dx] + q(x) u = f(x), quad 0 < x < 1, quad f in L2(0, 1),\
  q "измерима, ограничена, неотрицательна на" [0,1]\
  alpha = const > 0, space p in C^1 [0,1], space p(x) >= p_0 = const > 0\
  u in WW_2^1(0,1)
$
== Аппроксимация в пространстве $WW_2^1$
=== Основа вариацонно-сеточного метода
Пусть в гильбертовом пространстве $H$ действует линейный положительно-определенный оператор $A$ и требуется найти
решение уравнения
$
  A u = f, quad f in H
$
Принято вводить функционал энергии и энергетическую норму с энергетическим произведением:
$
  [u,v]_A := (A u,v),\
  norm(u)_A^2 := [u,u]_A = (A u,u),\
  cal(F)(u) := 1/2[u,u]_A - (f,u)
$
При положительной определенности оператора $A$ функционал энергии является выпуклым, из чего следует, что ноль его
производной является точкой минимума.
$
  cal(F)'(u)h = [u,h]_A - (f,h)\
  cal(F)'(u_0) = 0 <=> forall h in H quad [u_0,h]_A = (f,h) <=> A u_0 = f\
$
Если решение $u_0$ аппроксимируется в конечномерном пространстве $H_n$ с энергетическим произведением $[dot,dot]_A$, то
критерием минимальности функционала энергии в точке $u_n in H_n$ будет следующая система линейных уравнений:
$
  u_n = sum_(k=1)^n a_k phi_k, " где Lin" {phi_1,dots,phi_n} = H_n,\
  (cal(F) bar_H_n) '(u_n) = 0 <=> partial/(partial a_k) cal(F)(u_n) = 0, space k = 1,...,n\
  partial/(partial a_k) cal(F)(u_n) = partial/(partial a_k) [1/2 sum_(i=1)^n sum_(k=1)^n a_i a_k [phi_i, phi_k]_A - sum_(i=1)^n a_i (f, phi_i)] =\
  = sum_(i=1)^n a_i [phi_i, phi_k]_A - (f, phi_k) =0, space k = 1,...,n\
$<system>
Приведенная схема называется методом Ритца.

Основой сеточного метода аппроксимации является выбор функций $phi_i$, которые связаны с координатной сеткой в области
аппроксимации и задаются простыми формулами. Эти базисные функции $phi_i$ мы будем называть координатными функциями.
Выбор функций ограничен лишь условием полноты системы ${{phi_(n, i)}_(i=1)^k_n}_n$, где для каждого $n$ задается
подпространство $H_n$ размерности $k_n$ и функции $phi_(n, i)$ образуют базис в этом подпространстве, а полнота системы
-- это условие
$
  forall u in H space lim_(n -> oo) inf_(v_n in H_n) norm(u - v_n)_A = 0,
$
то есть любая функция $u$ может быть аппроксимирована с любой точностью в энергетической норме.

В книге @michbook показано, что если координатная система ${phi_(n, i)}$ полна в смысле описанном выше, то построенная
при помощи системы @system аппроксимация сходится в энергетической норме к решению исходного уравнения.

Р. Курантом в @kurant было показано, что необязательно выбирать последовательность подпространств $H_n$, которые строго
вложены друг в друга, как изначально предполагалось в методе Ритца, главное, чтобы система базисов этих пространств была
полна.

== Одномерный случай
Вернемся к поставленной задаче, в @methods описаны необходимые и достаточные условия для минимальной координатной
системы в $WW_p^s (Omega subset RR^m)$ вида
$
  {phi_(q, j, h) (x) = omega_q (x/h - j)}_(j in J_h, abs(q) = 0, ..., s-1),
$
которая при помощи функции $u_h$ аппроксимирует любую функцию $u in C_0^s (overline(Omega))$ в метрике $circle(WW)_p^s (Omega)$,
а также эту же функцию $u$ в метрике $C^(s-1) (K)$ для любого компакта $K subset Omega$ при $h -> 0$. Здесь $h$ -- шаг
сетки, $J_h$ -- конечный набор целых мультииндексов размера $m$, такой что $union.big_(j in J_h) "supp" phi_(q, j, h) supset Omega space forall q$,
а аппроксимирующая функция $u_h$ определяется как
$
  sum_(abs(q) = 0)^(s-1) sum_(j in J_h) h^q u^((q))((j+bb(1))h) omega_q (x/h-j)
$

В случае $WW_2^1(0,1)$ получается, что $q equiv 0$, то есть необходимо найти одну базисную функцию $omega(x) : RR -> RR$,
которая должна удовлетворять следующим условиям, описанным в @methods:
$
  "supp" omega = [0,2], space omega in C(RR)\
  omega(x+1) + omega(x) = 1 quad forall x in [0,1],\
  omega(x) = cases(phi(x) &"," space x in [0,1], psi(x-1) &"," space x in [1,2], 0 &"," space x in RR without [0,2]),\
  phi, psi: [0,1] -> RR "- полиномы степени не выше 1"
$
Что приводит к системе с четырьмя неизвестными:
$
  phi(x) = a x + b, space psi(x) = c x + d,\
  cases(
    0 = omega(0) = phi(0),
    1 = omega(1) = phi(1) = psi(0),
    0 = omega(2) = psi(1),
    1 = omega(x) + omega(x+1) = phi(x) + psi(x),

  )
$
Единственным решением системы является
$
  phi(x) = x, quad psi(x) = 1 - x,\
  omega(x) = cases(x &"," space x in [0,1], 2 - x &"," space x in [1,2], 0 &"," space x in RR without [0,2])
$

== Порядок аппроксимации
Вернемся к нашей задаче, одномерный случай, $s = 2$, $Omega = (0,1)$. Координатная система в этом случае имеет вид
$
  {phi_(j, h) (x) = omega (x/h - j)}_(j in J_h, abs(q) = 0, ..., s-1)
$
А аппроксимирующая функция имеет вид
$
  u_h(x) = sum_(j in J_h) u((j+1)h) omega (x/h - j)
$
Для удобства введем обозначение $x_j := j h$. Тогда на промежутке $[x_(j), x_(j+1)]$ ненулевыми $phi_(dot, h)$ будут
только $phi_(j, h)$ и $phi_(j-1, h)$.

Тогда на этом промежутке
$
  u_h (x) = u(x_(j+1)) phi_(j, h) (x) + u(x_j) phi_(j-1, h) (x),
$
но на каждом промежутке $[x_j, x_(j+1)]$ $phi_(dot, h)$ являются полиномами степени не выше 1, и верно $phi_(i-1,h) (x_i) = 1$,
то есть на самом деле мы имеем дело с линейной интерполяцией: вписываем ломаную в график функции $u$ в точках $x_j$.

Для интерполяционного многочлена есть оценка оценка остатка:
$
  x in [x_j, x_(j+1)] =>\
  abs(u(x) - u_h (x)) <= sup_(x in (x_j, x_(j+1))) u''(x) dot 1 / 2! abs((x-x_j)(x-x_(j+1)))
$
Несложно проверить, что $abs((x-x_j)(x-x_(j+1))) <= 1/4 h^2$, тогда
$
  norm(u-u_h)_C(0,1) <= 1/8 h^2 sup_(x in (0,1)) abs(u''(x))
$
То есть мы ожидаем не лучше, чем квадратичную сходимость.

== Применение к конкретной задаче
В качестве примера рассмотрим задачу
$
  -d /(dx) (x^alpha du/dx) + u = (3^(3-alpha)-2(3-alpha)x-1)/(3-alpha),\
  0 < x < 1 quad 1 <= alpha <= 2
$
Тогда $u(0) = 0$ и нужно ставить условие только на конце $u(1)$. Пусть $u(1) = 0$. Правая часть уравнения получалась
подстановкой
$
  u(x) = (x^(3-alpha)-1)/(3-alpha),
$
то есть это точное решение задачи.

Для удобства обозначим $n = ceil(1/h-1)$, тогда $J_h = {-1, ..., n}$.

По предложенному в начале методу строим аппроксимирующую функцию путем решения системы
$
  sum_(k=-1)^n a_k [phi_(k,h), phi_(j,h)] = (f, phi_(j,h)), quad j = -1,...,n
$
Расчеты производились в системе математических вычислений с точностью 8 знаков после запятой.

Результаты вычислений приведены в виде таблиц абсолютных погрешностей

#show table.cell.where(y: 0): strong
#set table(stroke: (x, y) => if y == 0 {
  (bottom: 0.7pt + black)
}, align: (x, y) => (if x > 0 { center } else { left }))

#figure(table(
  columns: 4,
  table.header([], [$h=0.01$], [$h=0.001$], [$h=0.0001$]),
  [0.0],
  [4.90e-5],
  [6.82e-7],
  [5.09e-3],
  [0.1],
  [1.57e-5],
  [1.57e-7],
  [5.33e-3],
  [0.2],
  [1.11e-5],
  [1.11e-7],
  [4.92e-3],
  [0.3],
  [8.53e-6],
  [8.53e-8],
  [4.36e-3],
  [0.4],
  [6.72e-6],
  [6.72e-8],
  [3.74e-3],
  [0.5],
  [5.29e-6],
  [5.29e-8],
  [3.09e-3],
  [0.6],
  [4.06e-6],
  [4.06e-8],
  [2.43e-3],
  [0.7],
  [2.96e-6],
  [2.96e-8],
  [1.78e-3],
  [0.8],
  [1.94e-6],
  [1.94e-8],
  [1.15e-3],
  [0.9],
  [9.55e-7],
  [9.55e-9],
  [5.55e-4],
), caption: [Абсолютные погрешности, $alpha=1$])

#grid(columns: (auto, auto), figure(table(
  columns: 3,
  table.header([], [$h=0.01$], [$h=0.001$]),
  [0.0],
  [2.34e-4],
  [8.26e-6],
  [0.1],
  [1.79e-5],
  [1.76e-7],
  [0.2],
  [1.04e-5],
  [1.03e-7],
  [0.3],
  [7.18e-6],
  [7.12e-8],
  [0.4],
  [5.26e-6],
  [5.22e-8],
  [0.5],
  [3.91e-6],
  [3.88e-8],
  [0.6],
  [2.86e-6],
  [2.84e-8],
  [0.7],
  [2.00e-6],
  [1.98e-8],
  [0.8],
  [1.26e-6],
  [1.25e-8],
  [0.9],
  [5.98e-7],
  [5.94e-9],
), caption: [Абсолютные погрешности, $alpha=1.5$]), figure(table(
  columns: 3,
  table.header([], [$h=0.01$], [$h=0.001$]),
  [0.0],
  [4.07e-4],
  [2.75e-5],
  [0.1],
  [1.13e-5],
  [1.09e-7],
  [0.2],
  [5.85e-6],
  [5.71e-8],
  [0.3],
  [3.80e-6],
  [3.72e-8],
  [0.4],
  [2.66e-6],
  [2.61e-8],
  [0.5],
  [1.91e-6],
  [1.88e-8],
  [0.6],
  [1.36e-6],
  [1.34e-8],
  [0.7],
  [9.25e-7],
  [9.11e-9],
  [0.8],
  [5.68e-7],
  [5.61e-9],
  [0.9],
  [2.65e-7],
  [2.62e-9],
), caption: [Абсолютные погрешности, $alpha=1.8$]))